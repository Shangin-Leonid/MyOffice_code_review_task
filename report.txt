
СУЩЕСТВЕННЫЕ ИЗМЕНЕНИЯ:



1. Исправлена ошибка выхода за границы массива:
    # 68: "i <= 16" -> "i < 16"
    # 72: "[16]" -> "[15]"

2. clearKey() вызывается в деструкторе ~FileEncryptor(), поэтому следует избавиться от
    выбрасывания исключения. Вообще непонятно, к чему там была проверка на nullptr:
    "delete nullptr" корректно.
    # 87-88

3. clearKey(), вызываемая в деструкторе ~FileEncryptor(), выбрасывает исключение.
    Недопустимо! Сделано noexcept:
    # 75, 85-91

4. Воспользуемся умным указателем вместо
    классического и забудем про возможные утечки.
    # 142, 154-156, 160-162:

5. Предпочтём std::unique_ptr классическому указателю, сняв с себя ответственность за
    владение ресурсом FileProcessorFactorySingleton:
    # 142-143: "..." -> "..."
    # 5, 115-128, 154-156, 160-162

6. Для FileProcessor добавлен необходимый виртуальный деструктор
    # 8:

7. Для файловых потоков добавлены проверки на успешность окрытия. Вот только как именно
    реагировать на ошибки, я не знаю.
    # 24, 45, 78

8. FileProcessor позволяет наследоваться от него, не переопределяя метод processFile().
    Сулит неожиданные выбросы исключений и падения там, где мы их не ждём.
    Для подобных целей C++ предусмотрел абстрактные базовые классы.
    Сделаем злосчастный метод чистым виртуальным:
    # 10-12

9. Судя по названию и логике использования, IdentityFileProcessor предполагался
    как разновидность FileProcessor. Тогда:
    # 18: "encodeFile(std::string fileContent)" -> "processFile(const std::string & filePath)"

10. Для конечных классов, наследованных от абстрактных, добавлен final, снят virtual с
    методов и добавлен для переопределённых функций override:
    # 15, 18, 21, 23, 36, 44, 63, 77, 85

11. Реализованы недостающие методы в FileCompressor:
    # 41-42
    Они дополнены соответствующими noexcept спецификаторами. Для этого создан
    псевдоним типа параметров - членов класса.
    Разработчик, оставивший данные методы нереализованными, должен был поставить
    заглушку: "static_assert(false, "FIXME");"

12. Если мы используем C++17, то обозначить параметер, как неиспользуемый, чтобы
    избежать предупреждений компилятора:
    # 18: "std::string filePath" -> "[[maybe_unused]] std::string filePath"
    Если стандарт ниже 17-ого, но используется GCC или CLang - "__attribute__((unused))".

13. Перенёс переменную instance внутрь метода getInstance, который теперь возвращает указатель.
    Я не силён в многопоточности, но знаю, что классический синглтон Майерса, начиная с C++11,
    является потокобезопасным и реализуется именно так. Кажется, не стоит тратить время на
    осознание этих тонкостей - в таком вопросе можно довериться опыту гуру.
    # 105-...

14. Следует ли поймать возможное исключение и как-то отреагировать на него?
    # 67: ...



ЛОГИКА РАБОТЫ ПРОГРАММЫ:



1. Нужно обработать случай несовпадения ни с одним из предусмотренных значений mode
    # 116-127: "if ... if ... if" -> "if ... else if ... else"



ВЛИЯЮЩИЕ ТОЛЬКО НА ЭФФЕКТИВНОСТЬ КОДА (ПАМЯТЬ, ВРЕМЯ):



1. Передача параметров (строк) по ссылке, а не по значению:
    # 10, 18, 23, 31, 38, 44, 52, 77, 93, 115:

2. Избавился от std::vector, убрав соответствующий заголовок, сократив
    затраты дополнительной памяти, время работы программы и время компиляции.
    # 4, 145-152:

3. Мне непонятно наличие поля compressionParams в FileCompressor. Предлагаю обойтись без него:
    # 58: "std::string compressionParams;" -> ""
    # 39, 54

4. Авось ускорит работу программы :-)
    # 68: "i++" -> "++i"



КУЛЬТУРА И ГИГИЕНА КОДА:



1. Форматирование, имена переменных (вкусовщина). Тут надо соответствовать стандартам,
    принятым в команде. В условии они не даны.

2. Не помешало бы магической константе 16 из # 68 присвоить имя.
    А 0x20 - какой-то определённый символ? Пробел? Тогда давайте прибавлять его.
    # 70: " + 0x20 " -> " + ' ' "

3. Предусмотренные значения mode можно оформить в виде констант, #define макросов или
    даже обратиться к "enum class : int", отойдя от строк и затрат на работу с ними.
    # 116-127:

3. Все пустые выражения в объявлениях и определениях заменены
    на void и /* empty */ (кроме аргументов деструкторов).

4.
    # 1-6:"#include "*"" -> "#include <*>"
          "time.h" -> "<ctime>"

5.
    # 163: "Sometihing" -> "Something"
    # 87: "!encryptionKey" -> "_encryptionKey == nullptr"
    Добавлены переводы строк в различных потоковых выводах.

6. "noexcept(false)" я бы убрал. Обязательной с точки зрения языка такая запись не является,
    ведь она равносильна своему отсутсвию. Однако загромождает код.
    Меньше слов => плотнее контекст => легче удерживается в голове => более читаемый и поддерживаемый код.



ПРЕДЛОЖЕНИЯ:



1. Вынести объявления классов в другой файл. Но это уже архитектура более высокого уровня.

2. Если некоторые классы используются только в данной единице трансляции, то стоит их
    обернуть в безымянное пространство имён. Но подозреваю, что в настоящем коде
    все объявления классов будут вынесены в другие файлы.

4. Можно добавить noexcept для всех функций, не вызывающих исключений. Хотя, наверное,
    в задании предполагается, что они внутри имеют более сложную логику и не позволяют это сделать.

5. Пожалуй, лучше в качестве исключений выбрасывать не строки, а какие-то
    собственные классы исключений, наследующиеся от стандартных.

6. Ежели это важно, то для ускорения ввода-вывода в потоки можно прибегнуть к разным
    спортивным хитростям.

7. К чему на 102 строчке "static_assert(std::is_nothrow_move_constructible<FileEncryptor>..." ?
    Чтобы код нельзя было компилировать без реализации move-конструктора? Тогда лучше
        "static_assert(false, "FileEncryptor need move constructor")".
    Чтобы гарантировать, что move конструктор, пусть и дефолтный, есть? Тогда ладно.
        Но почему проверка только для данного класса?

    Есть "правило пяти". Возможно, в каждом из классов стоит реализовать все 5 обязательных методов.

8. В языке C предусмотрены функции для парсинга параметров командной строки.
    Для получения значения mode можно воспользоваться <unistd.h> или <getopt.h>.
    Такая техника позволила бы при усложнении значений параметров легче переписать код на новый лад,
    не занимаясь разработкой собственных функций для парсинга и анализа пользовательского ввода.
